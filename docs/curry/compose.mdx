---
title: compose
description: Create a composition of functions
since: 12.1.0
---

### Usage

In a composition of functions, each function is given the next function as an argument and must call it to continue executing.

```ts
import * as _ from 'radashi'

const useZero = (fn: any) => () => fn(0)
const objectize = (fn: any) => (num: any) => fn({ num })
const increment =
  (fn: any) =>
  ({ num }: any) =>
    fn({ num: num + 1 })
const returnArg = (arg: any) => (args: any) => args[arg]

const composed = _.compose(
  useZero,
  objectize,
  increment,
  increment,
  returnArg('num'),
)

composed() // => 2
```

This can be a little jarring if you haven't seen it before. Here's a broken down composition. It's equivalent to the code above.

```ts
const decomposed = useZero(objectize(increment(increment(_.returnArg('num')))))

decomposed() // => 2
```

### Search terms

- Often called `composeFunctions`, `chain`, or `pipeline`

### Popular use cases

- Combining multiple transformation functions into a single function to process data sequentially.
- Creating middleware stacks where each function modifies data and passes it to the next one.
- Building reusable and composable utility functions by composing different operations in a modular way.
- Simplifying complex logic by breaking it into smaller, maintainable pieces that are composed together.
