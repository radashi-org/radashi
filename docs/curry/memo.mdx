---
title: memo
description: Memoize a function
since: 12.1.0
---

### Usage

Wrap a function with memo to get a function back that automagically returns values that have already been calculated.

```ts
import * as _ from 'radashi'

const timestamp = _.memo(() => Date.now())

const now = timestamp()
const later = timestamp()

now === later // => true
```

### Expiration

You can optionally pass a `ttl` (time to live) that will expire memoized results. In versions prior to version 10, `ttl` had a value of 300 milliseconds if not specified.

```ts
import * as _ from 'radashi'

const timestamp = _.memo(() => Date.now(), {
  ttl: 1000, // milliseconds
})

const now = timestamp()
const later = timestamp()

await _.sleep(2000)

const muchLater = timestamp()

now === later // => true
now === muchLater // => false
```

### Key Function

You can optionally customize how values are stored when memoized.

```ts
const timestamp = _.memo(
  ({ group }: { group: string }) => {
    const ts = Date.now()
    return `${ts}::${group}`
  },
  {
    key: ({ group }: { group: string }) => group,
  },
)

const now = timestamp({ group: 'alpha' })
const later = timestamp({ group: 'alpha' })
const beta = timestamp({ group: 'beta' })

now === later // => true
beta === now // => false
```

### Search terms

- Often called `memoize`, `cacheFunction`, or `remember`

### Popular use cases

- Optimizing performance by caching the results of expensive computations and reusing them when the same inputs occur.
- Reducing redundant calculations in recursive functions, such as those for generating Fibonacci sequences or factorials.
- Enhancing API efficiency by storing and reusing responses within a specified time window, preventing unnecessary calls.
- Controlling cache expiration using TTL (time-to-live) to ensure stale data is eventually recalculated or refetched.
